#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h> 
#include <Eigen/Dense>
#include <unsupported/Eigen/CXX11/Tensor>

#define NUM_NODES 4     
#define DIMENSIONS 2    
#define GAUSS_POINTS 2 

void ch(double gh2x2[2][2], double* gh1x3)
{

	gh1x3[0] = gh2x2[0][0];
	gh1x3[1] = gh2x2[1][1];
	gh1x3[2] = gh2x2[0][1] * 2;
}

void ch3(double gh3x3[3][3], double* gh1x4)
{

	gh1x4[0] = gh3x3[0][0];
	gh1x4[1] = gh3x3[1][1];
	gh1x4[2] = gh3x3[2][2];
	gh1x4[3] = gh3x3[0][1] * 2;
}

void chb3(double* gh1x4, double gh3x3[3][3])
{

	gh3x3[0][0] = gh1x4[0];
	gh3x3[0][1] = gh1x4[3] / 2;
	gh3x3[0][2] = 0;
	gh3x3[1][0] = gh1x4[3] / 2;
	gh3x3[1][1] = gh1x4[1];
	gh3x3[1][2] = 0;
	gh3x3[2][0] = 0;
	gh3x3[2][1] = 0;
	gh3x3[2][2] = gh1x4[2];

}

void chs3(double gh3x3[3][3], double* gh1x4)
{

	gh1x4[0] = gh3x3[0][0];
	gh1x4[1] = gh3x3[1][1];
	gh1x4[2] = gh3x3[2][2];
	gh1x4[3] = gh3x3[0][1];
}

void chsb3(double* gh1x4, double gh3x3[3][3])
{
	gh3x3[0][0] = gh1x4[0];
	gh3x3[0][1] = gh1x4[3];
	gh3x3[0][2] = 0;
	gh3x3[1][0] = gh1x4[3];
	gh3x3[1][1] = gh1x4[1];
	gh3x3[1][2] = 0;
	gh3x3[2][0] = 0;
	gh3x3[2][1] = 0;
	gh3x3[2][2] = gh1x4[2];
}

int i = 0;
int j = 0;
int k = 0;
int m = 0;
int n = 0;
int q = 0;



void assignment(double* new1, int n)
{
	for (i = 0; i < n; i++)
	{
		new1[i] = 0;
	}
}
void assignment(double new1[][2], int n)
{
	for (i = 0; i < n; i++)
	{
		for (j = 0; j < 2; j++)
		{
			new1[i][j] = 0;
		}
	}
}
void assignment(double new1[][3], int n)
{
	for (i = 0; i < n; i++)
	{
		for (j = 0; j < 3; j++)
		{
			new1[i][j] = 0;
		}
	}
}
void assignment(double new1[][4], int n)
{
	for (i = 0; i < n; i++)
	{
		for (j = 0; j < 4; j++)
		{
			new1[i][j] = 0;
		}
	}
}
void assignment(double new1[][5], int n)
{
	for (i = 0; i < n; i++)
	{
		for (j = 0; j < 5; j++)
		{
			new1[i][j] = 0;
		}
	}
}

void assignment(double new1[8][2][2])
{
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 2; j++)
		{
			for (k = 0; k < 2; k++)
			{
				new1[i][j][k] = 0;
			}
		}
	}
}
void assignment(double new1[][2][4], int n)
{
	for (i = 0; i < n; i++)
	{
		for (j = 0; j < 2; j++)
		{
			for (k = 0; k < 4; k++)
			{
				new1[i][j][k] = 0;
			}
		}
	}
}
void assignment(double new1[][4][4], int n)
{
	for (i = 0; i < n; i++)
	{
		for (j = 0; j < 4; j++)
		{
			for (k = 0; k < 4; k++)
			{
				new1[i][j][k] = 0;
			}
		}
	}
}
void assignment(double new1[8][3][3])
{
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 3; j++)
		{
			for (k = 0; k < 3; k++)
			{
				new1[i][j][k] = 0;
			}
		}
	}
}
void assignment(double new1[][8][2][2], int n)
{
	for (m = 0; m < n; m++) {
		for (i = 0; i < 8; i++)
		{
			for (j = 0; j < 2; j++)
			{
				for (k = 0; k < 2; k++)
				{
					new1[m][i][j][k] = 0;
				}
			}
		}
	}
}
void assignment(double new1[][8][2][4], int n)
{
	for (m = 0; m < n; m++) {
		for (i = 0; i < 8; i++)
		{
			for (j = 0; j < 2; j++)
			{
				for (k = 0; k < 4; k++)
				{
					new1[m][i][j][k] = 0;
				}
			}
		}
	}
}
void assignment(double new1[][8][4][4], int n)
{
	for (m = 0; m < n; m++) {
		for (i = 0; i < 8; i++)
		{
			for (j = 0; j < 4; j++)
			{
				for (k = 0; k < 4; k++)
				{
					new1[m][i][j][k] = 0;
				}
			}
		}
	}
}


int lc[4][2] = { {-1, -1}, {1, -1}, {1, 1}, {-1, 1} };

int E0 = 3 * 1000;
double mu = 0.3;
double D0 = E0 / (1 - pow(mu, 2));



void getDe(double De[4][4])
{
	De[0][0] = 1; De[0][1] = mu; De[0][2] = 0; De[0][3] = 0;
	De[1][0] = mu; De[1][1] = 1; De[1][2] = 0; De[1][3] = 0;
	De[2][0] = 0; De[2][1] = 0; De[2][2] = 0; De[2][3] = 0;
	De[3][0] = 0; De[3][1] = 0; De[3][2] = 0; De[3][3] = (1 - mu) / 2;

	for (j = 0; j < 4; j++) {
		for (k = 0; k < 4; k++) {
			De[j][k] *= D0;
		}
	}
}
//插值变量的积分
void getHlist(double* Hlist)
{
	Hlist[0] = 4.0;
	Hlist[1] = 0;
	Hlist[2] = 0;
	Hlist[3] = 0;
	Hlist[4] = 4 / 3.0;
	Hlist[5] = 4 / 3.0;

}

//形函数及其导数的实现
void getNN(double* NN, double dNN_dkk[4][2], double* kk)
{

	for (i = 0; i < 4; i++)
	{
		NN[i] = 1.0 / 4 * (1 + lc[i][0] * kk[0]) * (1 + lc[i][1] * kk[1]);
	}

	//形函数对局部坐标的导数

	dNN_dkk[0][0] = 0.25 * (-1 + kk[1]);
	dNN_dkk[0][1] = 0.25 * (-1 + kk[0]);

	dNN_dkk[1][0] = 0.25 * (1 - kk[1]);
	dNN_dkk[1][1] = 0.25 * (-1 - kk[0]);

	dNN_dkk[2][0] = 0.25 * (1 + kk[1]);
	dNN_dkk[2][1] = 0.25 * (1 + kk[0]);

	dNN_dkk[3][0] = 0.25 * (-1 - kk[1]);
	dNN_dkk[3][1] = 0.25 * (1 - kk[0]);

}

//插值函数值的实现
void getSubsq(double subsq[4][2])
{
	for (i = 0; i < 4; i++)
	{
		subsq[i][0] = lc[i][0] * 0;
		subsq[i][1] = lc[i][1] * 0;

	}
}


//计算矩阵的行列式
double determinant(double matrix[DIMENSIONS][DIMENSIONS]) {
	Eigen::Matrix2d gh2x2;
	for (j = 0; j < 2; j++) {
		for (k = 0; k < 2; k++) {
			gh2x2(j, k) = matrix[j][k];
		}
	}

	return gh2x2.determinant();
}


int getInverseMatrix(double matrix[2][2], double inverse[2][2]) {
	double det = determinant(matrix);
	if (det == 0) {
		printf("矩阵不可逆！");
		return 0; // 矩阵不可逆
	}
	Eigen::Matrix2d gb;
	for (j = 0; j < 2; j++) {
		for (k = 0; k < 2; k++) {
			gb(j, k) = matrix[j][k];
		}
	}
	Eigen::Matrix2d inverseMat = gb.inverse();
	for (j = 0; j < 2; j++) {
		for (k = 0; k < 2; k++) {
			inverse[j][k] = inverseMat(j, k);
		}
	}
	return 1; // 矩阵有逆
}
int getInverseMatrix(double matrix[4][4], double inverse[4][4]) {

	Eigen::MatrixXd gb(4, 4);
	for (j = 0; j < 4; j++) {
		for (k = 0; k < 4; k++) {
			gb(j, k) = matrix[j][k];
		}
	}
	Eigen::MatrixXd inverseMat = gb.inverse();
	for (j = 0; j < 4; j++) {
		for (k = 0; k < 4; k++) {
			inverse[j][k] = inverseMat(j, k);
		}
	}
	return 1; // 矩阵有逆
}
int getInverseMatrix(double matrix[5][5], double inverse[5][5]) {

	Eigen::MatrixXd gb(5, 5);
	for (j = 0; j < 5; j++) {
		for (k = 0; k < 5; k++) {
			gb(j, k) = matrix[j][k];
		}
	}
	Eigen::MatrixXd inverseMat = gb.inverse();
	for (j = 0; j < 5; j++) {
		for (k = 0; k < 5; k++) {
			inverse[j][k] = inverseMat(j, k);
		}
	}
	return 1; // 矩阵有逆
}

//雅可比矩阵的计算
void getJacobian(double xyz0[4][2], double uvw0[4][2], double dNN_dkk[NUM_NODES][DIMENSIONS], double Jac[DIMENSIONS][DIMENSIONS])
{

	//计算雅可比矩阵
	for (i = 0; i < NUM_NODES; i++) {
		for (j = 0; j < DIMENSIONS; j++) {
			for (k = 0; k < DIMENSIONS; k++) {
				Jac[k][j] += dNN_dkk[i][j] * (xyz0[i][k] + uvw0[i][k] / 2.0);
			}
		}
	}
}
void getJacobian2(double xyz0[4][2], double uvw0[4][2], double dNN_dkk[NUM_NODES][DIMENSIONS], double Jac[DIMENSIONS][DIMENSIONS])
{

	//计算雅可比矩阵
	for (i = 0; i < NUM_NODES; i++) {
		for (j = 0; j < DIMENSIONS; j++) {
			for (k = 0; k < DIMENSIONS; k++) {
				Jac[k][j] += dNN_dkk[i][j] * (xyz0[i][k] + uvw0[i][k]);
			}
		}
	}
}
//ul矩阵的计算
void getul(double uvw0[4][2], double dNN_dkk[NUM_NODES][DIMENSIONS], double ul[DIMENSIONS][DIMENSIONS])
{
	//计算ul矩阵
	for (i = 0; i < NUM_NODES; i++) {
		for (j = 0; j < DIMENSIONS; j++) {
			for (k = 0; k < DIMENSIONS; k++) {
				ul[k][j] += dNN_dkk[i][j] * uvw0[i][k];
			}
		}
	}
}
void getdul(double dNN_dkk[NUM_NODES][DIMENSIONS], double ul[DIMENSIONS][DIMENSIONS])
{
	for (i = 0; i < NUM_NODES; i++) {
		for (j = 0; j < DIMENSIONS; j++) {
			for (k = 0; k < DIMENSIONS; k++) {
				ul[k][j] += dNN_dkk[i][j] * 1;
			}
		}
	}
}

void getuldu(double  uldu[8][2][2], double dNN_dkk[4][2])
{
	assignment(uldu);
	for (m = 0; m < 4; m++) {
		for (j = 0; j < 2; j++) {
			for (k = 0; k < 2; k++) {
				if (j == k) {
					for (i = 0; i < 2; i++) {
						uldu[j + 2 * m][k][i] = dNN_dkk[m][i];
					}
				}
				else {
					for (i = 0; i < 2; i++) {
						uldu[j][k][i] = 0;
					}
				}
			}
		}
	}
}

void getMatXMat(double x[2][2], double y[2][2], double z[2][2])
{
	Eigen::Matrix2d x1;
	for (j = 0; j < 2; j++) {
		for (k = 0; k < 2; k++) {
			x1(j, k) = x[j][k];
		}
	}
	Eigen::Matrix2d y1;
	for (j = 0; j < 2; j++) {
		for (k = 0; k < 2; k++) {
			y1(j, k) = y[j][k];
		}
	}
	Eigen::Matrix2d z1;
	z1 = x1 * y1;
	for (j = 0; j < 2; j++) {
		for (k = 0; k < 2; k++) {
			z[j][k] = z1(j, k);
		}
	}
}
void getMatXMat(double x[3][3], double y[3][3], double z[3][3])
{
	Eigen::Matrix3d x1;
	for (j = 0; j < 3; j++) {
		for (k = 0; k < 3; k++) {
			x1(j, k) = x[j][k];
		}
	}
	Eigen::Matrix3d y1;
	for (j = 0; j < 3; j++) {
		for (k = 0; k < 3; k++) {
			y1(j, k) = y[j][k];
		}
	}
	Eigen::Matrix3d z1;
	z1 = x1 * y1;
	for (j = 0; j < 3; j++) {
		for (k = 0; k < 3; k++) {
			z[j][k] = z1(j, k);
		}
	}
}
double Id[2][2] = { {1,0},{0,1} };
double Id3[3][3] = { {1,0,0},{0,1,0},{0,0,1} };
double Id4[4][4] = { {1,0,0,0},{0,1,0,0},{0,0,1,0} ,{0,0,0,1} };

void getEqsdle(double eqsdle[5][4], double* le, double* ep, double* depV, double dlamda)
{
	double sig_1 = 1 / 3.0 * (-4285.71 * (-depV[0] - ep[0] + le[0]) - 4285.71 * (-depV[1] - ep[1] + le[1]));
	double sig_2 = (3296.7 * (-depV[0] - ep[0] + le[0]) + 989.011 * (-depV[1] - ep[1] + le[1])) + sig_1;
	double sig_3 = (989.011 * (-depV[0] - ep[0] + le[0]) + 3296.7 * (-depV[1] - ep[1] + le[1])) + sig_1;
	double sig_4 = 1153.846154 * (-depV[3] - ep[3] + le[3]);
	double fenmu = pow(sig_1, 2) + pow(sig_2, 2) + pow(sig_3, 2) + 2 * pow(sig_4, 2);
	double x1 = (-2.0 / 3 * sig_1 + 4.0 / 3 * sig_2 - 2.0 / 3 * sig_3);
	double x2 = (-2.0 / 3 * sig_1 - 2.0 / 3 * sig_2 + 4.0 / 3 * sig_3);
	double x3 = (4.0 / 3 * sig_1 - 2.0 / 3 * sig_2 - 2.0 / 3 * sig_3);
	double y1 = -(2857.14 * (sig_1)-3736.26 * (sig_2)+879.121 * sig_3);
	double y2 = -(2857.14 * (sig_1)+879.12 * (sig_2)-3736.26 * sig_3);
	double y3 = 0;

	eqsdle[0][0] = -((0.306186 * dlamda) * x1 * y1 / pow(fenmu, 1.5)) + 2287.98 * dlamda / pow(fenmu, 0.5);
	eqsdle[0][1] = -((0.306186 * dlamda) * x1 * y2 / pow(fenmu, 1.5)) - 538.349 * dlamda / pow(fenmu, 0.5);
	eqsdle[0][2] = 0;
	eqsdle[0][3] = -((1413.167159 * dlamda) * x1 * sig_4) / pow(fenmu, 1.5);


	eqsdle[1][0] = -((0.306186 * dlamda) * x2 * y1) / pow(fenmu, 1.5) - 538.349 * dlamda / pow(fenmu, 0.5);
	eqsdle[1][1] = -((0.306186 * dlamda) * x2 * y2 / pow(fenmu, 1.5)) + 2287.98 * dlamda / pow(fenmu, 0.5);
	eqsdle[1][2] = 0;
	eqsdle[1][3] = -((1413.167159 * dlamda) * x2 * sig_4) / pow(fenmu, 1.5);


	eqsdle[2][0] = -((0.306186 * dlamda) * x3 * y1) / pow(fenmu, 1.5) - 1749.64 * dlamda / pow(fenmu, 0.5);
	eqsdle[2][1] = -((0.306186 * dlamda) * x3 * y2) / pow(fenmu, 1.5) - 1749.64 * dlamda / pow(fenmu, 0.5);
	eqsdle[2][2] = 0;
	eqsdle[2][3] = -((1413.167159 * dlamda) * x3 * sig_4) / pow(fenmu, 1.5);


	eqsdle[3][0] = -(1.224745 * dlamda * y1 * sig_4 / pow(fenmu, 1.5));
	eqsdle[3][1] = -(1.224745 * dlamda * y2 * sig_4 / pow(fenmu, 1.5));
	eqsdle[3][2] = 0;
	eqsdle[3][3] = -(5652.668637 * dlamda * pow(sig_4, 2) / pow(fenmu, 1.5)) + 2826 * dlamda / pow(fenmu, 0.5);


	eqsdle[4][0] = 0.612372 * y1 / pow(fenmu, 0.5);
	eqsdle[4][1] = 0.612372 * y2 / pow(fenmu, 0.5);
	eqsdle[4][2] = 0;
	eqsdle[4][3] = 2826.33 * sig_4 / pow(fenmu, 0.5);
}
void getEqsdep(double eqsdep[5][4], double* le, double* ep, double* depV, double dlamda)
{
	double sig_1 = 1 / 3.0 * (-4285.71 * (-depV[0] - ep[0] + le[0]) - 4285.71 * (-depV[1] - ep[1] + le[1]));
	double sig_2 = (3296.7 * (-depV[0] - ep[0] + le[0]) + 989.011 * (-depV[1] - ep[1] + le[1])) + sig_1;
	double sig_3 = (989.011 * (-depV[0] - ep[0] + le[0]) + 3296.7 * (-depV[1] - ep[1] + le[1])) + sig_1;
	double sig_4 = 1153.846154 * (-depV[3] - ep[3] + le[3]);
	double fenmu = pow(sig_1, 2) + pow(sig_2, 2) + pow(sig_3, 2) + 2 * pow(sig_4, 2);
	double x1 = (-2.0 / 3 * sig_1 + 4.0 / 3 * sig_2 - 2.0 / 3 * sig_3);
	double x2 = (-2.0 / 3 * sig_1 - 2.0 / 3 * sig_2 + 4.0 / 3 * sig_3);
	double x3 = (4.0 / 3 * sig_1 - 2.0 / 3 * sig_2 - 2.0 / 3 * sig_3);
	double y1 = (2857.14 * (sig_1)-3736.26 * (sig_2)+879.121 * sig_3);
	double y2 = (2857.14 * (sig_1)+879.12 * (sig_2)-3736.26 * sig_3);
	double y3 = 0;

	eqsdep[0][0] = -((0.306186 * dlamda) * x1 * y1 / pow(fenmu, 1.5)) - 2287.98 * dlamda / pow(fenmu, 0.5);
	eqsdep[0][1] = -((0.306186 * dlamda) * x1 * y2 / pow(fenmu, 1.5)) + 538.349 * dlamda / pow(fenmu, 0.5);
	eqsdep[0][2] = 0;
	eqsdep[0][3] = ((1413.167159 * dlamda) * x1 * sig_4) / pow(fenmu, 1.5);

	eqsdep[1][0] = -((0.306186 * dlamda) * x2 * y1) / pow(fenmu, 1.5) + 538.349 * dlamda / pow(fenmu, 0.5);
	eqsdep[1][1] = -((0.306186 * dlamda) * x2 * y2 / pow(fenmu, 1.5)) - 2287.98 * dlamda / pow(fenmu, 0.5);
	eqsdep[1][2] = 0;
	eqsdep[1][3] = ((1413.167159 * dlamda) * x2 * sig_4) / pow(fenmu, 1.5);


	eqsdep[2][0] = -((0.306186 * dlamda) * x3 * y1) / pow(fenmu, 1.5) + 1749.64 * dlamda / pow(fenmu, 0.5);
	eqsdep[2][1] = -((0.306186 * dlamda) * x3 * y2) / pow(fenmu, 1.5) + 1749.64 * dlamda / pow(fenmu, 0.5);
	eqsdep[2][2] = 0;
	eqsdep[2][3] = ((1413.167159 * dlamda) * x3 * sig_4) / pow(fenmu, 1.5);


	eqsdep[3][0] = -(1.224745 * dlamda * y1 * sig_4 / pow(fenmu, 1.5));
	eqsdep[3][1] = -(1.224745 * dlamda * y2 * sig_4 / pow(fenmu, 1.5));
	eqsdep[3][2] = -(1.224745 * dlamda * y3 * sig_4 / pow(fenmu, 1.5));
	eqsdep[3][3] = (5652.668637 * dlamda * pow(sig_4, 2) / pow(fenmu, 1.5)) - 2826 * dlamda / pow(fenmu, 0.5);


	eqsdep[4][0] = 0.612372 * y1 / pow(fenmu, 0.5);
	eqsdep[4][1] = 0.612372 * y2 / pow(fenmu, 0.5);
	eqsdep[4][2] = 0;
	eqsdep[4][3] = -2826.33 * sig_4 / pow(fenmu, 0.5);
}
void dmaterial(double eqsdvar[5][5], double* le, double* ep, double peeq, double* depV, double dlamda)
{
	double sig_1 = 1 / 3.0 * (-4285.71 * (-depV[0] - ep[0] + le[0]) - 4285.71 * (-depV[1] - ep[1] + le[1]));
	double sig_2 = (3296.7 * (-depV[0] - ep[0] + le[0]) + 989.011 * (-depV[1] - ep[1] + le[1])) + sig_1;
	double sig_3 = (989.011 * (-depV[0] - ep[0] + le[0]) + 3296.7 * (-depV[1] - ep[1] + le[1])) + sig_1;
	double sig_4 = 1153.846154 * (-depV[3] - ep[3] + le[3]);
	double fenmu = pow(sig_1, 2) + pow(sig_2, 2) + pow(sig_3, 2) + 2 * pow(sig_4, 2);
	double x1 = (-2.0 / 3 * sig_1 + 4.0 / 3 * sig_2 - 2.0 / 3 * sig_3);
	double x2 = (-2.0 / 3 * sig_1 - 2.0 / 3 * sig_2 + 4.0 / 3 * sig_3);
	double x3 = (4.0 / 3 * sig_1 - 2.0 / 3 * sig_2 - 2.0 / 3 * sig_3);
	double y1 = (2857.14 * (sig_1)-3736.26 * (sig_2)+879.121 * sig_3);
	double y2 = (2857.14 * (sig_1)+879.12 * (sig_2)-3736.26 * sig_3);
	double y3 = 0;
	eqsdvar[0][0] = -1 - ((0.306186 * dlamda) * x1 * y1 / pow(fenmu, 1.5)) - 2287.98 * dlamda / pow(fenmu, 0.5);
	eqsdvar[0][1] = -((0.306186 * dlamda) * x1 * y2) / pow(fenmu, 1.5) + 538.349 * dlamda / pow(fenmu, 0.5);
	eqsdvar[0][2] = 0;
	eqsdvar[0][3] = ((1413.167159 * dlamda) * x1 * sig_4) / pow(fenmu, 1.5);
	eqsdvar[0][4] = 0.61237223724 * x1 / pow(fenmu, 0.5);

	eqsdvar[1][0] = -((0.306186 * dlamda) * x2 * y1) / pow(fenmu, 1.5) + 538.349 * dlamda / pow(fenmu, 0.5);
	eqsdvar[1][1] = -1 - ((0.306186 * dlamda) * x2 * y2 / pow(fenmu, 1.5)) - 2287.98 * dlamda / pow(fenmu, 0.5);
	eqsdvar[1][2] = 0;
	eqsdvar[1][3] = ((1413.167159 * dlamda) * x2 * sig_4) / pow(fenmu, 1.5);
	eqsdvar[1][4] = 0.61237223724 * x2 / pow(fenmu, 0.5);

	eqsdvar[2][0] = -((0.306186 * dlamda) * x3 * y1) / pow(fenmu, 1.5) + 1749.64 * dlamda / pow(fenmu, 0.5);
	eqsdvar[2][1] = -((0.306186 * dlamda) * x3 * y2) / pow(fenmu, 1.5) + 1749.64 * dlamda / pow(fenmu, 0.5);
	eqsdvar[2][2] = -1;
	eqsdvar[2][3] = ((1413.167159 * dlamda) * x3 * sig_4) / pow(fenmu, 1.5);
	eqsdvar[2][4] = 0.61237223724 * x3 / pow(fenmu, 0.5);

	eqsdvar[3][0] = -(1.224745 * dlamda * y1 * sig_4 / pow(fenmu, 1.5));
	eqsdvar[3][1] = -(1.224745 * dlamda * y2 * sig_4 / pow(fenmu, 1.5));
	eqsdvar[3][2] = 0;
	eqsdvar[3][3] = -1 + (5652.668637 * dlamda * pow(sig_4, 2) / pow(fenmu, 1.5)) - 2826.3343186 * dlamda / pow(fenmu, 0.5);
	eqsdvar[3][4] = 2.449490 * sig_4 / pow(fenmu, 0.5);

	double z0 = 1.0 / 3 * (-depV[0] - depV[1] - depV[2]);
	double z01 = (depV[0] + z0);
	double z02 = (depV[1] + z0);
	double z03 = (depV[2] + z0);
	double z1 = 4.0 / 3 * z01 - 2.0 / 3 * z02 - 2.0 / 3 * z03;
	double z2 = -2.0 / 3 * z01 + 4.0 / 3 * z02 - 2.0 / 3 * z03;
	double z3 = -2.0 / 3 * z01 - 2.0 / 3 * z02 + 4.0 / 3 * z03;
	double fenmu2 = pow(z01, 2) + pow(z02, 2) + pow(z03, 2) + 0.5 * pow(depV[3], 2);
	eqsdvar[4][0] = -((40.824829 * z1) / pow(fenmu2, 0.5)) + (0.612372 * y1) / pow(fenmu, 0.5);
	eqsdvar[4][1] = -((40.824829 * z2) / pow(fenmu2, 0.5)) + (0.612372 * y2) / pow(fenmu, 0.5);
	eqsdvar[4][2] = -((40.824829 * z3) / pow(fenmu2, 0.5)) + (0.612372 * y3) / pow(fenmu, 0.5);
	eqsdvar[4][3] = -((40.824829 * depV[3]) / pow(fenmu2, 0.5)) - (2826.3343186 * sig_4) / pow(fenmu, 0.5);
	eqsdvar[4][4] = 0;

}
void getDirec(double* sig01V, double* direc)
{
	double fenmu = 0;
	double a0 = 1.0 / 3 * (-sig01V[0] - sig01V[1] - sig01V[2]);
	double a1 = sig01V[0] + a0;
	double a2 = sig01V[1] + a0;
	double a3 = sig01V[2] + a0;
	double a4 = 2 * (pow(sig01V[3], 2));
	fenmu = sqrt(pow(a1, 2) + pow(a2, 2) + pow(a3, 2) + a4);

	direc[0] = (4.0 / 3 * a1 - 2.0 / 3 * a2 - 2.0 / 3 * a3) * 0.612372 / fenmu;
	direc[1] = (-2.0 / 3 * a1 + 4.0 / 3 * a2 - 2.0 / 3 * a3) * 0.612372 / fenmu;
	direc[2] = (-2.0 / 3 * a1 - 2.0 / 3 * a2 + 4.0 / 3 * a3) * 0.612372 / fenmu;
	direc[3] = 2.44949 * sig01V[3] / fenmu;


}
void getSig(double* x, double y[4][4], double* z)
{
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			z[i] += y[i][j] * x[j]; // 按照矩阵乘法规则累加
		}
	}
}
void material(double* le, double* ep, double peeq, double* depVdlamda, double* eq, double eqsdvar[5][5], double* sig01V, double& peeq01)
{
	double depV[4] = { 0 };
	double dlamda = depVdlamda[4];
	for (j = 0; j < 4; j++) {
		depV[j] = depVdlamda[j];
	}

	double ee[4] = { 0 };
	for (j = 0; j < 4; j++) {
		ee[j] = le[j] - ep[j] - depV[j];
	}
	double De[4][4] = { 0 };
	getDe(De);

	double sig01[3][3] = { 0 };
	getSig(ee, De, sig01V);
	chsb3(sig01V, sig01);

	double p = (-1.0 / 3) * (sig01[0][0] + sig01[1][1] + sig01[2][2]);
	double S[3][3] = { 0 };
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			S[i][j] = sig01[i][j] + p * Id3[i][j];
		}
	}
	double E1[3][3] = { 0 };
	double dep[3][3] = { 0 };

	chb3(depV, dep);
	double pe = (-1.0 / 3) * (dep[0][0] + dep[1][1] + dep[2][2]);
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			E1[i][j] = dep[i][j] - pe * Id3[i][j];
		}
	}
	double q = 0;
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			q += S[i][j] * S[i][j];
		}
	}
	q = sqrt(3.0 / 2 * q);

	double direc[4] = { 0 };
	getDirec(sig01V, direc);

	double dpeeq = 0;
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			dpeeq += E1[i][j] * E1[i][j];
		}
	}
	dpeeq = sqrt(2.0 / 3 * dpeeq);

	for (j = 0; j < 4; j++) {
		eq[j] = dlamda * direc[j] - depV[j];
	}
	eq[4] = q - (100 * (peeq + dpeeq) + 50);

	dmaterial(eqsdvar, le, ep, peeq, depV, dlamda);

	peeq01 = peeq + dpeeq;

}
void newton(double* le, double* ep, double peeq, double* depVdlamda, double inJac0[5][5], double* sigV, double& peeq1)
{
	double x_current[5] = { 0 };

	for (k = 0; k < 5; k++) {
		x_current[k] = 0.000001;
	}
	double eq[5] = { 0 };
	double eqsdvar[5][5] = { 0 };
	double sig01V[4] = { 0 };
	double peeq01 = 0;
	material(le, ep, peeq, x_current, eq, eqsdvar, sig01V, peeq01);

	double tolerance = 0.000001;
	double x_next[5] = { 0 };
	int it_count = 0;
	double Res[5] = { 0 };
	double Res_norm = 0;
	double dds[5] = { 0 };
	double Jac[5][5] = { 0 };

	double inJac[5][5] = { 0 };

	while (it_count < 10)
	{
		Res_norm = 0;
		for (i = 0; i < 5; i++) {
			for (j = 0; j < 5; j++) {
				Jac[i][j] = eqsdvar[i][j];
			}
		}

		getInverseMatrix(Jac, inJac);



		for (j = 0; j < 5; j++) {
			Res[j] = 0 - eq[j];
			Res_norm += pow(Res[j], 2);
		}

		Res_norm = pow(Res_norm, 0.5);

		if (Res_norm <= tolerance)
		{

			break;
		}
		for (i = 0; i < 5; i++) {
			for (j = 0; j < 5; j++) {
				dds[i] += inJac[i][j] * Res[j];
			}
		}

		for (i = 0; i < 5; i++) {
			x_current[i] += dds[i];
		}
		assignment(eq, 5);
		assignment(eqsdvar, 5);
		assignment(sig01V, 4);
		peeq01 = 0;
		material(le, ep, peeq, x_current, eq, eqsdvar, sig01V, peeq01);

		Res_norm = 0;
		assignment(dds, 5);
		it_count++;
	}

	for (i = 0; i < 5; i++) {
		depVdlamda[i] = x_current[i];
	}

	for (i = 0; i < 5; i++) {
		for (j = 0; j < 5; j++) {
			inJac0[i][j] = inJac[i][j];
		}
	}

	for (i = 0; i < 4; i++) {
		sigV[i] = sig01V[i];
	}

	peeq1 = peeq01;

}
void getK(double sigdle[4][4], double sigdep[4][4], double* depVdlamda, double* le, double* ep, double inJac0[5][5])
{
	assignment(sigdle, 4);
	assignment(sigdep, 4);
	double De[4][4] = { 0 };
	getDe(De);
	double depV[4] = { 0 };
	double dlamda = depVdlamda[4];
	for (j = 0; j < 4; j++) {
		depV[j] = depVdlamda[j];
	}
	double eqsdle[5][4] = { 0 };
	double eqsdep[5][4] = { 0 };
	getEqsdle(eqsdle, le, ep, depV, dlamda);
	getEqsdep(eqsdep, le, ep, depV, dlamda);


	double depdle[5][4] = { 0 };
	double depdep[5][4] = { 0 };
	for (i = 0; i < 5; i++) {
		for (j = 0; j < 4; j++) {
			for (k = 0; k < 5; k++) {
				depdle[i][j] += inJac0[i][k] * (-eqsdle[k][j]);
			}
		}
	}
	for (i = 0; i < 5; i++) {
		for (j = 0; j < 4; j++) {
			for (k = 0; k < 5; k++) {
				depdep[i][j] += inJac0[i][k] * (-eqsdep[k][j]);
			}
		}
	}

	double temp1[4][4] = { 0 };
	double temp2[4][4] = { 0 };

	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			temp1[i][j] = Id4[i][j] - depdle[i][j];
		}
	}
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			for (k = 0; k < 4; k++) {
				sigdle[i][j] += De[i][k] * temp1[k][j];
			}
		}
	}
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			temp2[i][j] = -Id4[i][j] - depdep[i][j];
		}
	}
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			for (k = 0; k < 4; k++) {
				sigdep[i][j] += De[i][k] * temp2[k][j];
			}
		}
	}
	
}
void getSig2(double* le, double* ep, double peeq, double* sigV, double* ep1, double& peeq1, double sigdle[4][4], double sigdep[4][4])
{

	double ee0[4] = { 0 };
	for (j = 0; j < 4; j++) {
		ee0[j] = le[j] - ep[j];
	}
	double De[4][4] = { 0 };
	getDe(De);
	double sig0V[4] = { 0 };
	double sig0[3][3] = { 0 };
	getSig(ee0, De, sig0V);
	chsb3(sig0V, sig0);


	double sigma_s = 100 * peeq + 50;
	double p = (-1.0 / 3) * (sig0[0][0] + sig0[1][1] + sig0[2][2]);
	double S0[3][3] = { 0 };
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			S0[i][j] = sig0[i][j] + p * Id3[i][j];
		}
	}
	double q0 = 0;
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			q0 += S0[i][j] * S0[i][j];
		}
	}
	q0 = sqrt(3.0 / 2 * q0);

	if ((q0 - sigma_s) <= 0)
	{
		for (j = 0; j < 4; j++) {
			sigV[j] = sig0V[j];
			ep1[j] = ep[j];
		}
		peeq1 = peeq;
		for (i = 0; i < 4; i++) {
			for (j = 0; j < 4; j++) {
				sigdle[i][j] = De[i][j];
			}
		}
		for (i = 0; i < 4; i++) {
			for (j = 0; j < 4; j++) {
				sigdep[i][j] = -(De[i][j]);
			}
		}
	}
	else
	{
		double depVdlamda[5] = { 0 };
		double inJac0[5][5] = { 0 };
		newton(le, ep, peeq, depVdlamda, inJac0, sigV, peeq1);
		getK(sigdle, sigdep, depVdlamda, le, ep, inJac0);

		for (j = 0; j < 4; j++) {
			ep1[j] = ep[j] + depVdlamda[j];
		}
	}

}

void transposeMatrix(double matrix[2][2], double transposed[2][2])
{
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 2; j++) {
			transposed[j][i] = matrix[i][j];
		}
	}
}

void divM(double ingb[2][2], double ingbdgb[2][2][2][2])
{
	for (i = 0; i < 2; i++)
	{
		for (j = 0; j < 2; j++)
		{
			for (k = 0; k < 2; k++)
			{
				for (m = 0; m < 2; m++)
				{
					ingbdgb[m][i][k][j] = -ingb[i][j] * ingb[k][m];
				}
			}

		}
	}

}
void divM(double ingb[3][3], double ingbdgb[3][3][3][3])
{
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 3; j++)
		{
			for (k = 0; k < 3; k++)
			{
				for (m = 0; m < 3; m++)
				{
					ingbdgb[m][i][k][j] = -ingb[i][j] * ingb[k][m];
				}
			}

		}
	}

}



void getiR(double iRm[3][3], double iRdu[8][2][2], double iRTdu[8][2][2], double iwm[3][3], double iwdu[8][2][2])
{

	double iR1m[3][3] = { 0 };
	double IiR1[3][3] = { 0 };
	double iR2m[3][3] = { 0 };
	double iR1du[8][2][2] = { 0 };
	double iR2du[8][2][2] = { 0 };
	double IiR1diR1[3][3][3][3] = { 0 };
	double IiR1du[8][2][2] = { 0 };

	for (i = 0; i < 3; i++) {
		for (k = 0; k < 3; k++) {
			iR1m[i][k] = Id3[i][k] - iwm[i][k] / 2.0;

		}
	}
	Eigen::Matrix3d iR1m_;
	for (i = 0; i < 3; i++) {
		for (k = 0; k < 3; k++) {
			iR1m_(i, k) = iR1m[i][k];
		}
	}
	iR1m_.inverse();
	for (i = 0; i < 3; i++) {
		for (k = 0; k < 3; k++) {
			IiR1[i][k] = iR1m_(i, k);
		}
	}
	for (i = 0; i < 3; i++) {
		for (k = 0; k < 3; k++) {
			iR2m[i][k] = Id3[i][k] + iwm[i][k] / 2.0;

		}
	}
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			for (k = 0; k < 3; k++) {
				iRm[i][j] += IiR1[i][k] * iR2m[k][j];

			}
		}
	}
	for (i = 0; i < 8; i++) {
		for (j = 0; j < 2; j++) {
			for (k = 0; k < 2; k++) {
				iR1du[i][j][k] = -0.5 * iwdu[i][j][k];
			}
		}
	}
	for (i = 0; i < 8; i++) {
		for (j = 0; j < 2; j++) {
			for (k = 0; k < 2; k++) {
				iR2du[i][j][k] = 0.5 * iwdu[i][j][k];
			}
		}
	}
	divM(IiR1, IiR1diR1);
	for (m = 0; m < 8; m++) {
		for (i = 0; i < 2; i++) {
			for (j = 0; j < 2; j++) {
				for (k = 0; k < 2; k++) {
					for (n = 0; n < 2; n++) {
						IiR1du[m][i][j] += IiR1diR1[k][n][i][j] * iR1du[m][k][n];

					}
				}

			}
		}
	}
	for (m = 0; m < 8; m++) {
		for (i = 0; i < 2; i++) {
			for (k = 0; k < 2; k++) {
				for (j = 0; j < 2; j++) {
					iRdu[m][i][k] += IiR1du[m][i][j] * iR2m[j][k] + IiR1[i][j] * iR2du[m][j][k];

				}

			}

		}
	}
	for (i = 0; i < 8; i++) {
		for (j = 0; j < 2; j++) {
			for (k = 0; k < 2; k++) {
				iRTdu[i][j][k] = iRdu[i][k][j];
			}
		}
	}


}
double M2i[4][4] = { 0 };
double coefdU2i[4][4] = { 0 };
double dcoefdU21i[8][4][4] = { 0 };
void compute_dcoefdU2(double xyz0[4][2], double U2[4][2], double dMdU2[8][4][4], double dcoefdU2[8][4][4]) {

	assignment(M2i, 4);
	assignment(coefdU2i, 4);
	assignment(dcoefdU21i, 8);
	for (int i = 0; i < 4; i++) {
		M2i[i][0] = 1;
		M2i[i][1] = xyz0[i][0] + U2[i][0];
		M2i[i][2] = xyz0[i][1] + U2[i][1];
		M2i[i][3] = lc[i][0] * lc[i][1];

	}

	getInverseMatrix(M2i, coefdU2i);


	//计算dcoefdU2


	for (int a = 0; a < 8; a++) {
		for (int i = 0; i < 4; i++) {
			for (int b = 0; b < 4; b++) {
				for (int j = 0; j < 4; j++) {
					dcoefdU21i[a][i][b] += -coefdU2i[i][j] * dMdU2[a][j][b];
				}
			}
		}
	}

	for (int a = 0; a < 8; a++) {
		for (int i = 0; i < 4; i++) {
			for (int b = 0; b < 4; b++) {
				for (int j = 0; j < 4; j++) {
					dcoefdU2[a][i][b] += dcoefdU21i[a][i][j] * coefdU2i[j][b];
				}
			}
		}
	}

}

void compute_ddcoefdU2(double xyz0[4][2], double U1[4][2], double ddcoefdU2[8][8][4][4], double h, double dMdU2[8][4][4], double dcoefdU2[8][4][4]) {
	double U2[4][2] = { 0 };
	double getDcoefdU21[8][4][4] = { 0 };
	double getDcoefdU2[8][8][4][4] = { 0 };
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 2; j++) {
			U2[i][j] = U1[i][j];
		}
	}

	for (int k = 0; k < 4; k++) {
		for (int m = 0; m < 2; m++) {
			U2[k][m] = U2[k][m] + h;
			int n = (k) * 2 + m;
			compute_dcoefdU2(xyz0, U2, dMdU2, getDcoefdU2[n]);
			U2[k][m] -= h;


		}
	}

	for (n = 0; n < 8; n++) {
		for (m = 0; m < 8; m++) {
			for (i = 0; i < 4; i++) {
				for (j = 0; j < 4; j++) {
					ddcoefdU2[n][m][i][j] = (getDcoefdU2[n][m][i][j] - dcoefdU2[m][i][j]) / h;
				}
			}
		}
	}

}
double NN[4] = { 0 };
double dNN_dkk[4][2] = { 0 };
double U1[4][2] = { 0 };
double dU1[8][4][2] = { 0 };
double dU2[8][4][2] = { 0 };
double M[4][4] = { 0 };
double coefdU[4][4] = { 0 };
double dMdU1[8][4][4] = { 0 };
double dcoefdU11[8][4][4] = { 0 };
double dcoefdU1[8][4][4] = { 0 };
double coef[2][4] = { 0 };
double coefdu[8][2][4] = { 0 };

double Jac[2][2] = { 0 };
double inJac[2][2] = { 0 };
double isl[2][2] = { 0 };
double islT[2][2] = { 0 };
double isldu[8][2][2] = { 0 };
double is[2][2] = { 0 };
double iw[2][2] = { 0 };

double ism[3][3] = { 0 };
double isdu[8][2][2] = { 0 };

double iwm[3][3] = { 0 };
double iwdu[8][2][2] = { 0 };
double iRm[3][3] = { 0 };
double iRmT[3][3] = { 0 };
double iRdu[8][2][2] = { 0 };
double iRTdu[8][2][2] = { 0 };

double epm[3][3] = { 0 };
double ledu[8][2][2] = { 0 };
double epdu[8][2][2] = { 0 };
double leVm[4] = { 0 };
double leduV[8][3] = { 0 };
double leduVm[8][4] = { 0 };
double epVm[4] = { 0 };
double epduV[8][3] = { 0 };
double epduVm[8][4] = { 0 };

double Jac1[2][2] = { 0 };
double Jac2[2][2] = { 0 };
double inJac2[2][2] = { 0 };
double inJac2T[2][2] = { 0 };
double detJac2 = 0;

double IJac2du[8][2][2] = { 0 };
double Jac2du[8][2][2] = { 0 };
double detJac2dJac2[2][2] = { 0 };
double detJac2du[8] = { 0 };
double sigVm[4] = { 0 };
double sigduV[8][4] = { 0 };

double sigdu[8][3][3] = { 0 };

double sigdle[4][4] = { 0 };
double sigdep[4][4] = { 0 };
double M2[4][4] = { 0 };
double coefdU2[4][4] = { 0 };
double dMdU2[8][4][4] = { 0 };
double dcoefdU21[8][4][4] = { 0 };
double dcoefdU2[8][4][4] = { 0 };
double ddcoefdU2[8][8][4][4] = { 0 };
double coef02[2][4] = { 0 };
double dcoef02[8][2][4] = { 0 };
double ux2[2][2] = { 0 };
double ux2T[2][2] = { 0 };
double dux2[8][2][2] = { 0 };
double ddux2[8][8][2][2] = { 0 };
double is2[2][2] = { 0 };
double is2du[8][2][2] = { 0 };
double dis2du[8][8][2][2] = { 0 };
double is2m[3][3] = { 0 };
double de[8][3][3] = { 0 };
double dde[8][8][3][3] = { 0 };

double temp[8] = { 0 };
double a[2][2] = { 0 };
double aV[3] = { 0 };
double temp01[3][3] = { 0 };
double temp02[3][3] = { 0 };
double temp03[3][3] = { 0 };
double ddcoef02[8][8][2][4] = { 0 };

double inJacT[2][2] = { 0 };
void CPS4R(double lem[3][3], double sigm[3][3], double peeq0, double* ep1V, double& peeq1, double leu[3][3], double ep0[3][3], double De[4][4], double xyz0[4][2], double uvw0[4][2], double* kk, double* virwork, double dvirwork[8][8])
{


	assignment(NN, 4);
	assignment(dNN_dkk, 4);
	assignment(Jac, 2);
	assignment(Jac1, 2);
	assignment(inJac, 2);


	assignment(isl, 2);
	assignment(islT, 2);
	assignment(isldu);
	assignment(is, 2);
	assignment(iw, 2);
	assignment(isdu);
	assignment(iwdu);

	assignment(inJacT, 2);
	assignment(coefdU, 4);
	assignment(dcoefdU11, 8);
	assignment(dcoefdU1, 8);
	assignment(coef, 4);
	assignment(coefdu, 8);


	getNN(NN, dNN_dkk, kk);

	//计算U1

	for (i = 0; i < 4; i++) {
		for (j = 0; j < 2; j++) {
			U1[i][j] = uvw0[i][j];

		}
	}
	//计算dU1

	for (m = 0; m < 8; m++) {
		for (i = 0; i < 4; i++) {
			for (j = 0; j < 2; j++) {
				if (i == (m) / 2.0 and j == 0)
				{
					dU1[m][i][j] = 1;

				}

				if (i == (m - 1) / 2.0 and j == 1)
				{
					dU1[m][i][j] = 1;

				}

			}
		}
	}

	//计算coefdU

	for (i = 0; i < 4; i++) {
		M[i][0] = 1;
		M[i][1] = xyz0[i][0] + uvw0[i][0] / 2;
		M[i][2] = xyz0[i][1] + uvw0[i][1] / 2;
		M[i][3] = lc[i][0] * lc[i][1];

	}

	getInverseMatrix(M, coefdU);

	for (m = 0; m < 8; m++) {
		for (i = 0; i < 4; i++) {
			for (j = 0; j < 4; j++) {
				if (i == (m) / 2.0)
				{
					if (j == 1) {
						dMdU1[m][i][j] = 1 / 2.0;
					}
				}
				if (i == (m - 1) / 2.0)
				{
					if (j == 2) {
						dMdU1[m][i][j] = 1 / 2.0;
					}
				}

			}
		}
	}
	for (m = 0; m < 8; m++) {
		for (i = 0; i < 4; i++) {
			for (k = 0; k < 4; k++) {
				for (j = 0; j < 4; j++) {
					dcoefdU11[m][i][k] += -coefdU[i][j] * dMdU1[m][j][k];
				}
			}
		}
	}

	for (m = 0; m < 8; m++) {
		for (i = 0; i < 4; i++) {
			for (k = 0; k < 4; k++) {
				for (j = 0; j < 4; j++) {
					dcoefdU1[m][i][k] += dcoefdU11[m][i][j] * coefdU[j][k];
				}
			}
		}
	}
	//计算coef与coefdu

	for (i = 0; i < 4; i++) {
		for (k = 0; k < 2; k++) {
			for (j = 0; j < 4; j++) {
				coef[k][i] += coefdU[i][j] * U1[j][k];
			}
		}
	}
	
	for (m = 0; m < 8; m++) {
		for (i = 0; i < 4; i++) {
			for (k = 0; k < 2; k++) {
				for (j = 0; j < 4; j++) {
					coefdu[m][k][i] += coefdU[i][j] * dU1[m][j][k] + dcoefdU1[m][i][j] * U1[j][k];
				}
			}
		}
	}

	//计算雅可比矩阵
	getNN(NN, dNN_dkk, kk);
	getJacobian(xyz0, uvw0, dNN_dkk, Jac1);
	transposeMatrix(Jac1, Jac);
	getInverseMatrix(Jac, inJac);

	transposeMatrix(inJac, inJacT);


	double polydx1[4][2] = { {0,0},{1,0},{0,1},{0,0} };
	double polydkk[4][2] = { {0,0},{0,0},{0,0},{kk[2],kk[1]} };
	double polydx2[4][2] = { 0 };
	for (i = 0; i < 4; i++) {
		for (k = 0; k < 2; k++) {
			for (j = 0; j < 2; j++) {
				polydx2[i][k] += polydkk[i][j] * inJac[j][k];
			}
		}
	}
	double polydx[4][2] = { 0 };
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 2; j++) {
			polydx[i][j] = polydx1[i][j] + polydx2[i][j];
		}
	}

	//求ux以及uxdu
	/*double isl[2][2] = { 0 };*/
	for (i = 0; i < 2; i++) {
		for (k = 0; k < 2; k++) {
			for (j = 0; j < 4; j++) {
				isl[i][k] += coef[i][j] * polydx[j][k];
			}
		}
	}

	transposeMatrix(isl, islT);
	for (m = 0; m < 8; m++) {
		for (i = 0; i < 2; i++) {
			for (k = 0; k < 2; k++) {
				for (j = 0; j < 4; j++) {
					isldu[m][i][k] += coefdu[m][i][j] * polydx[j][k];
				}
			}
		}
	}

	for (i = 0; i < 2; i++) {
		for (j = 0; j < 2; j++) {
			is[i][j] = (isl[i][j] + islT[i][j]) / 2.0;
		}
	}


	for (m = 0; m < 8; m++) {
		for (i = 0; i < 2; i++) {
			for (k = 0; k < 2; k++) {
				isdu[m][i][k] = 0.5 * (isldu[m][i][k] + isldu[m][k][i]);

			}
		}
	}

	for (i = 0; i < 2; i++) {
		for (j = 0; j < 2; j++) {
			iw[i][j] = (isl[i][j] - islT[i][j]) / 2.0;
		}
	}
	for (m = 0; m < 8; m++) {
		for (i = 0; i < 2; i++) {
			for (k = 0; k < 2; k++) {
				iwdu[m][i][k] = 0.5 * (isldu[m][i][k] - isldu[m][k][i]);
			}
		}
	}

	double IJac2dJac2[2][2][2][2] = { 0 };
	assignment(sigVm, 4);
	assignment(sigduV, 8);

	assignment(sigdu);
	assignment(Jac2, 2);
	assignment(inJac2, 2);
	assignment(inJac2T, 2);

	detJac2 = 0;
	assignment(IJac2du);

	assignment(Jac2du);
	assignment(detJac2dJac2, 2);
	assignment(detJac2du, 8);


	assignment(ism, 3);
	assignment(iwm, 3);
	assignment(iRm, 3);
	assignment(iRmT, 3);

	assignment(epm, 2);
	assignment(leVm, 4);
	assignment(epVm, 4);
	assignment(ledu);
	assignment(epdu);
	assignment(leduV, 8);
	assignment(epduV, 8);
	assignment(leduVm, 8);

	assignment(epduVm, 8);

	assignment(iRdu);
	assignment(iRTdu);


	ism[0][0] = is[0][0]; ism[0][1] = is[0][1]; ism[0][2] = 0;
	ism[1][0] = is[1][0]; ism[1][1] = is[1][1]; ism[1][2] = 0;
	ism[2][0] = 0; ism[2][1] = 0; ism[2][2] = 0;
	iwm[0][0] = iw[0][0]; iwm[0][1] = iw[0][1]; iwm[0][2] = 0;
	iwm[1][0] = iw[1][0]; iwm[1][1] = iw[1][1]; iwm[1][2] = 0;
	iwm[2][0] = 0; iwm[2][1] = 0; iwm[2][2] = 0;

	getiR(iRm, iRdu, iRTdu, iwm, iwdu);

	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			iRmT[j][i] = iRm[i][j];
		}
	}

	getMatXMat(iRm, leu, temp01);
	getMatXMat(temp01, iRmT, temp02);
	for (j = 0; j < 3; j++) {
		for (k = 0; k < 3; k++) {
			lem[j][k] = ism[j][k] + temp02[j][k];
		}
	}

	getMatXMat(leu, iRmT, temp03);
	for (m = 0; m < 8; m++) {
		for (i = 0; i < 2; i++) {
			for (k = 0; k < 2; k++) {
				for (j = 0; j < 2; j++) {
					ledu[m][i][k] += iRdu[m][i][j] * temp03[j][k] + temp01[i][j] * iRTdu[m][j][k];

				}

			}
		}
	}
	for (i = 0; i < 8; i++) {
		for (j = 0; j < 2; j++) {
			for (k = 0; k < 2; k++) {
				ledu[i][j][k] += isdu[i][j][k];
			}
		}
	}


	getMatXMat(iRm, ep0, temp01);
	getMatXMat(temp01, iRmT, epm);
	getMatXMat(ep0, iRmT, temp03);
	for (m = 0; m < 8; m++) {
		for (i = 0; i < 2; i++) {
			for (k = 0; k < 2; k++) {
				for (j = 0; j < 2; j++) {
					epdu[m][i][k] += iRdu[m][i][j] * temp03[j][k] + temp01[i][j] * iRTdu[m][j][k];

				}
			}
		}
	}


	ch3(lem, leVm);
	for (i = 0; i < 8; i++) {
		for (j = 0; j < 2; j++) {
			for (k = 0; k < 2; k++) {
				a[j][k] = ledu[i][j][k];
			}
		}
		ch(a, aV);
		for (k = 0; k < 3; k++) {
			leduV[i][k] = aV[k];
		}
	}
	for (i = 0; i < 8; i++) {
		leduVm[i][0] = leduV[i][0];
		leduVm[i][1] = leduV[i][1];
		leduVm[i][2] = 0;
		leduVm[i][3] = leduV[i][2];
	}


	ch3(epm, epVm);

	for (i = 0; i < 8; i++) {
		for (j = 0; j < 2; j++) {
			for (k = 0; k < 2; k++) {
				a[j][k] = epdu[i][j][k];
			}
		}
		ch(a, aV);
		for (k = 0; k < 3; k++) {
			epduV[i][k] = aV[k];
		}
	}

	for (k = 0; k < 8; k++) {
		leduVm[k][0] = leduV[k][0];
		leduVm[k][1] = leduV[k][1];
		leduVm[k][2] = 0;
		leduVm[k][3] = leduV[k][2];
	}

	for (k = 0; k < 8; k++) {
		epduVm[k][0] = epduV[k][0];
		epduVm[k][1] = epduV[k][1];
		epduVm[k][2] = 0;
		epduVm[k][3] = epduV[k][2];
	}


	getSig2(leVm, epVm, peeq0, sigVm, ep1V, peeq1, sigdle, sigdep);


	for (k = 0; k < 8; k++) {
		for (j = 0; j < 4; j++) {
			for (i = 0; i < 4; i++) {
				sigduV[k][j] += sigdle[i][j] * leduVm[k][i] + sigdep[i][j] * epduVm[k][i];
			}
		}
	}
	chsb3(sigVm, sigm);

	for (i = 0; i < 8; i++) {
		chsb3(sigduV[i], sigdu[i]);
	}

	//---------------------------------------------------
	//求coefdU2
	assignment(coefdU2, 4);
	assignment(dcoefdU21, 8);
	assignment(dcoefdU2, 8);
	assignment(ddcoefdU2, 8);
	assignment(coef02, 4);
	assignment(dcoef02, 4);
	assignment(ddcoef02, 8);
	for (i = 0; i < 4; i++) {
		M2[i][0] = 1;
		M2[i][1] = xyz0[i][0] + uvw0[i][0];
		M2[i][2] = xyz0[i][1] + uvw0[i][1];
		M2[i][3] = lc[i][0] * lc[i][1];
	}

	getInverseMatrix(M2, coefdU2);

	//计算dcoefdU2
	for (m = 0; m < 8; m++) {
		for (i = 0; i < 4; i++) {
			for (j = 0; j < 2; j++) {
				if (i == (m) / 2.0)
				{
					if (j == 0) {
						dU1[m][i][j] = 1;
					}
				}
				if (i == (m - 1) / 2.0)
				{
					if (j == 1) {
						dU1[m][i][j] = 1;
					}
				}

			}
		}
	}

	for (m = 0; m < 8; m++) {
		for (i = 0; i < 4; i++) {
			for (j = 0; j < 4; j++) {
				if (i == (m) / 2.0)
				{
					if (j == 1) {
						dMdU2[m][i][j] = 1;
					}
				}
				if (i == (m - 1) / 2.0)
				{
					if (j == 2) {
						dMdU2[m][i][j] = 1;
					}
				}

			}
		}
	}

	for (m = 0; m < 8; m++) {
		for (i = 0; i < 4; i++) {
			for (k = 0; k < 4; k++) {
				for (j = 0; j < 4; j++) {
					dcoefdU21[m][i][k] += -coefdU2[i][j] * dMdU2[m][j][k];
				}
			}
		}
	}

	for (m = 0; m < 8; m++) {
		for (i = 0; i < 4; i++) {
			for (k = 0; k < 4; k++) {
				for (j = 0; j < 4; j++) {
					dcoefdU2[m][i][k] += dcoefdU21[m][i][j] * coefdU2[j][k];
				}
			}
		}
	}

	compute_ddcoefdU2(xyz0, U1, ddcoefdU2, 0.0000001, dMdU2, dcoefdU2);

	//计算coef与coefdu

	for (i = 0; i < 4; i++) {
		for (k = 0; k < 2; k++) {
			for (j = 0; j < 4; j++) {
				coef02[k][i] += coefdU2[i][j] * U1[j][k];
			}
		}
	}
	assignment(dcoef02, 8);
	assignment(ddcoef02, 8);
	for (m = 0; m < 8; m++) {
		for (i = 0; i < 4; i++) {
			for (k = 0; k < 2; k++) {
				for (j = 0; j < 4; j++) {
					dcoef02[m][k][i] += coefdU2[i][j] * dU1[m][j][k] + dcoefdU2[m][i][j] * U1[j][k];
				}
			}
		}
	}

	for (m = 0; m < 8; m++) {
		for (n = 0; n < 8; n++) {
			for (i = 0; i < 4; i++) {
				for (k = 0; k < 2; k++) {
					for (j = 0; j < 4; j++) {
						ddcoef02[m][n][k][i] += dcoefdU2[n][i][j] * dU1[m][j][k] + dcoefdU2[m][i][j] * dU1[n][j][k] + ddcoefdU2[n][m][i][j] * U1[j][k];
					}
				}
			}
		}
	}


	getJacobian2(xyz0, uvw0, dNN_dkk, Jac2);

	getInverseMatrix(Jac2, inJac2);

	//计算Jac2du
	getuldu(Jac2du, dNN_dkk);

	//计算雅可比行列式
	detJac2 = determinant(Jac2);

	divM(inJac2, IJac2dJac2);
	for (m = 0; m < 8; m++) {
		for (i = 0; i < 2; i++) {
			for (j = 0; j < 2; j++) {
				for (k = 0; k < 2; k++) {
					for (n = 0; n < 2; n++) {
						IJac2du[m][i][j] += IJac2dJac2[k][n][i][j] * Jac2du[m][k][n];

					}
				}
			}
		}
	}

	transposeMatrix(inJac2, inJac2T);
	//计算行列式的导数

	for (i = 0; i < 2; i++) {
		for (j = 0; j < 2; j++) {
			detJac2dJac2[i][j] = detJac2 * inJac2T[i][j];

		}
	}
	for (n = 0; n < 8; n++) {
		for (i = 0; i < 2; i++) {
			for (j = 0; j < 2; j++) {
				detJac2du[n] += detJac2dJac2[i][j] * Jac2du[n][i][j];
			}
		}
	}

	double polydxd1[4][2] = { {0,0},{1,0},{0,1},{0,0} };

	//注意，这里的polydkk就不是全0了，kk1和kk2应该是符号表示

	double polydxd2[4][2] = { 0 };
	for (i = 0; i < 4; i++) {
		for (k = 0; k < 2; k++) {
			for (j = 0; j < 2; j++) {
				polydxd2[i][k] += polydkk[i][j] * inJac2[j][k];
			}
		}
	}
	double dpolydxd[8][4][2] = { 0 };
	for (m = 0; m < 8; m++) {
		for (i = 0; i < 4; i++) {
			for (k = 0; k < 2; k++) {
				for (j = 0; j < 2; j++) {
					dpolydxd[m][i][k] += polydkk[i][j] * IJac2du[m][j][k];
				}
			}
		}
	}
	double polydxd[4][2] = { 0 };
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 2; j++) {
			polydxd[i][j] = polydxd1[i][j] + polydxd2[i][j];
		}
	}

	//求ux2以及dux2
	assignment(ux2, 2);
	assignment(dux2);
	assignment(ddux2, 8);

	for (i = 0; i < 2; i++) {
		for (k = 0; k < 2; k++) {
			for (j = 0; j < 4; j++) {
				ux2[i][k] += coef02[i][j] * polydxd[j][k];
			}
		}
	}
	transposeMatrix(ux2, ux2T);

	for (m = 0; m < 8; m++) {
		for (i = 0; i < 2; i++) {
			for (k = 0; k < 2; k++) {
				for (j = 0; j < 4; j++) {
					dux2[m][i][k] += dcoef02[m][i][j] * polydxd[j][k] + coef02[i][j] * dpolydxd[m][j][k];
				}
			}
		}
	}


	for (n = 0; n < 8; n++) {
		for (m = 0; m < 8; m++) {
			for (i = 0; i < 2; i++) {
				for (k = 0; k < 2; k++) {
					for (j = 0; j < 4; j++) {
						ddux2[m][n][i][k] += ddcoef02[n][m][i][j] * polydxd[j][k];
					}
				}
			}
		}
	}



	for (i = 0; i < 2; i++) {
		for (j = 0; j < 2; j++) {
			is2[i][j] = (ux2[i][j] + ux2T[i][j]) / 2.0;
		}
	}


	for (m = 0; m < 8; m++) {
		for (i = 0; i < 2; i++) {
			for (k = 0; k < 2; k++) {
				is2du[m][i][k] = 0.5 * (dux2[m][i][k] + dux2[m][k][i]);
			}
		}
	}

	for (m = 0; m < 8; m++) {
		for (n = 0; n < 8; n++) {
			for (i = 0; i < 2; i++) {
				for (k = 0; k < 2; k++) {
					dis2du[m][n][i][k] = 0.5 * (ddux2[m][n][i][k] + ddux2[m][n][k][i]);
				}
			}
		}
	}

	is2m[0][0] = is2[0][0]; is2m[0][1] = is2[0][1]; is2m[0][2] = 0;
	is2m[1][0] = is2[1][0]; is2m[1][1] = is2[1][1]; is2m[1][2] = 0;
	is2m[2][0] = 0; is2m[2][1] = 0; is2m[2][2] = 0;


	for (m = 0; m < 8; m++) {
		for (i = 0; i < 2; i++) {
			for (j = 0; j < 2; j++) {
				de[m][i][j] = is2du[m][i][j];
			}
		}
	}

	for (m = 0; m < 8; m++) {
		for (n = 0; n < 8; n++) {
			for (i = 0; i < 2; i++) {
				for (j = 0; j < 2; j++) {
					dde[m][n][i][j] = dis2du[m][n][i][j];
				}
			}
		}
	}


	for (i = 0; i < 8; i++) {
		for (j = 0; j < 3; j++) {
			for (k = 0; k < 3; k++) {
				virwork[i] += detJac2 * de[i][j][k] * sigm[j][k];
			}
		}
		virwork[i] *= 4;
	}


	for (m = 0; m < 8; m++) {
		for (n = 0; n < 8; n++) {
			for (i = 0; i < 3; i++) {
				for (j = 0; j < 3; j++) {
					dvirwork[m][n] += detJac2 * de[n][i][j] * sigdu[m][i][j];
					dvirwork[m][n] += detJac2 * dde[m][n][i][j] * sigm[i][j];
					dvirwork[m][n] += detJac2du[m] * de[n][i][j] * sigm[i][j];
				}
			}
			dvirwork[m][n] *= 4;
		}
	}

}
void getGlobalFint(double Fintall[], const double f10[], const int labelOfElement0[]) {
	int elementDofs[8] = { 0 }; // 存储8个自由度索引

	// 生成自由度索引数组
	for (int i = 0; i < 4; ++i) {
		int node = labelOfElement0[i]; // 节点码为1-based
		int base = 2 * (node - 1);
		// 转换为0-based的起始索引
		elementDofs[(2 * i)] = base;
		elementDofs[(2 * i + 1)] = base + 1;
	}

	// 将单元内力累加到全局数组
	for (int i = 0; i < 8; ++i) {
		Fintall[elementDofs[i]] += f10[i];
	}

}
void getGlobalK(double Kall[12][12], const double k10[8][8], const int labelOfElement0[]) {
	int elementDofs[8]; // 存储8个自由度索引

	// 生成自由度索引数组
	for (int i = 0; i < 4; ++i) {
		int node = labelOfElement0[i]; // 节点码为1-based
		int base = 2 * (node - 1);     // 转换为0-based的起始索引
		elementDofs[2 * i] = base;
		elementDofs[2 * i + 1] = base + 1;
	}

	// 将单元内力累加到全局数组
	for (int i = 0; i < 8; ++i) {
		for (int j = 0; j < 8; ++j) {
			Kall[elementDofs[i]][elementDofs[j]] += k10[i][j];
		}
	}
}

double kk[2] = { 0 };
double Subsq[4][2] = { 0 };

double De[4][4] = { 0 };


double sig[2][3][3] = { 0 };

void combination(
	// 输入参数
	double xyz0[6][2],    // 节点坐标 [6][2]
	double uvw0[6][2],    // 节点位移 [6][2]
	double leu[2][3][3] = { 0 },  // 初始全应变 [2][3][3]
	double ep0[2][3][3] = { 0 },  // 初始塑性应变 [2][3][3]
	double peeq0[2] = { 0 },      // 等效塑性应变 [2]

	// 输出参数
	double globalF2[12] = { 0 },        // 最终内力向量
	double globalK2[12][12] = { 0 },    // 最终刚度矩阵
	double let[2][3][3] = { 0 },           // 单元1全应变
	double ept[2][3][3] = { 0 },           // 单元1塑性应变
	double peeqt[2] = { 0 }              // 单元1等效塑性应变
	
) {
	getSubsq(Subsq);
	getDe(De);


	for (int j = 0; j < 2; j++)
	{
		kk[j] = Subsq[1][j];
	}


	// 定义两个单元的节点映射（1-based编号）
	const int jdm[2][4] = { {1,2,3,4}, {4,3,5,6} };

	// 临时存储单元计算结果
	double Fint1[8] = { 0 };
	double Fint2[8] = { 0 };
	double KK1[8][8] = { 0 };
	double KK2[8][8] = { 0 };
	double temp_peeq1 = 0;
	double temp_peeq2 = 0;
	double temp_ept1[4] = { 0 };
	double temp_ept2[4] = { 0 }; // 假设cps4R返回的塑性应变是4元素形式

	// 处理第一个单元 -------------------------------------------
	{
		// 提取单元1的节点坐标和位移（转换为0-based索引）
		double xyz1[4][2], uvw1[4][2];
		for (int j = 0; j < 4; j++) {
			int node_idx = jdm[0][j] - 1; // 转换为0-based
			for (int k = 0; k < 2; k++) {
				xyz1[j][k] = xyz0[node_idx][k];
				uvw1[j][k] = uvw0[node_idx][k];
			}
		}

		// 调用单元计算函数

		CPS4R(let[0], sig[0], peeq0[0], temp_ept1, temp_peeq1, leu[0], ep0[0], De, xyz1, uvw1, kk, Fint1, KK1);

		// 转换塑性应变格式
		chb3(temp_ept1, ept[0]); // 假设temp_ept1来自cps4R的输出
		peeqt[0] = temp_peeq1;


	}

	// 处理第二个单元 -------------------------------------------
	{
		// 提取单元2的节点坐标和位移
		double xyz2[4][2], uvw2[4][2];
		for (int j = 0; j < 4; j++) {
			int node_idx = jdm[1][j] - 1; // 转换为0-based
			for (int k = 0; k < 2; k++) {
				xyz2[j][k] = xyz0[node_idx][k];
				uvw2[j][k] = uvw0[node_idx][k];
			}
		}

		// 调用单元计算函数

		CPS4R(let[1], sig[1], peeq0[1], temp_ept2, temp_peeq2, leu[1], ep0[1], De, xyz2, uvw2, kk, Fint2, KK2);

		// 转换塑性应变格式
		chb3(temp_ept2, ept[1]);
		peeqt[1] = temp_peeq2;
	}

	// 组装全局矩阵 ---------------------------------------------
	// 初始化全局矩阵
	memset(globalF2, 0, sizeof(double) * 12);
	memset(globalK2, 0, sizeof(double) * 12 * 12);

	// 转换节点码为当前函数使用的1-based编号
	int element1_nodes[4] = { 1,2,3,4 };
	int element2_nodes[4] = { 4,3,5,6 };

	// 累加单元贡献
	getGlobalFint(globalF2, Fint1, element1_nodes);
	getGlobalFint(globalF2, Fint2, element2_nodes);

	getGlobalK(globalK2, KK1, element1_nodes);
	getGlobalK(globalK2, KK2, element2_nodes);
}
void test1()
{
	double xyz0[6][2] = { {0, 1}, {0, 0}, {1, 0}, {1, 1}, {2, 0}, {2, 0.5} };
	double uvw0[6][2] = { {0.05, 0}, {-0.05, 0}, {0.05, 0}, {0, 0}, {0.05, 0}, {0, 0} };
	double leu[2][3][3] = { 0 };  // 初始全应变 [2][3][3]
	double ep0[2][3][3] = { 0 };  // 初始塑性应变 [2][3][3]
	double peeq0[2] = { 0 };      // 等效塑性应变 [2]

	// 输出参数
	double globalF2[12] = { 0 };        // 最终内力向量
	double globalK2[12][12] = { 0 };   // 最终刚度矩阵
	double let[2][3][3] = { 0 };           // 单元1全应变
	double ept[2][3][3] = { 0 };           // 单元1塑性应变
	double peeqt[2] = { 0 };
	combination(xyz0, uvw0, leu, ep0, peeq0, globalF2, globalK2, let, ept, peeqt);
	
	printf("Fint=\n");
	for (int k = 0; k < 12; k++) {
		printf("%7.2f\t", globalF2[k]);
		if ((k + 1) % 2 == 0) {
			printf("\n");
		}

	}
	printf("\nKK=\n");
	for (int j = 0; j < 12; j++) {
		for (int k = 0; k < 12; k++) {
			printf("%7.2f\t", globalK2[j][k]);
			if ((k + 1) % 4 == 0) {
				printf("\n");
			}
		}
		printf("\n");
	}
	printf("ep=\n");
	for (int j = 0; j < 2; j++) {
		for (int i = 0; i < 3; i++) {
			for (k = 0; k < 3; k++) {
				printf("%7.6f\t", ept[j][i][k]);
			}
		}
	}
	printf("\n");
	printf("peeq=   ");
	for (int j = 0; j < 2; j++) {
		printf("%7.6f\t", peeqt[j]);
	}
	printf("\n");

}

int main()
{
	test1();

	return 0;
}
